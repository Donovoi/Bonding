name: Auto Release (Semver) on Push

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  CARGO_TERM_COLOR: always
  WINTUN_VERSION: "0.14.1"
  WINTUN_SHA256: "07c256185d6ee3652e09fa55c0b673e2624b565e02c4b9091c79ca7d2f24ef51"

permissions:
  contents: write

concurrency:
  group: semver-release
  cancel-in-progress: false

jobs:
  version:
    name: Compute next version
    runs-on: ubuntu-latest
    outputs:
      next_tag: ${{ steps.semver.outputs.next_tag }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Compute next version tag
        id: semver
        shell: bash
        run: |
          set -euo pipefail

          msg="$(git log -1 --pretty=%B)"
          echo "Commit message:"$'\n'"$msg"$'\n'

          bump="patch"
          if echo "$msg" | grep -qiE 'BREAKING CHANGE|(^|\n).*!:|(^|\n)feat!'; then
            bump="major"
          elif echo "$msg" | grep -qiE '(^|\n)feat(\(.+\))?:'; then
            bump="minor"
          elif echo "$msg" | grep -qiE '(^|\n)fix(\(.+\))?:'; then
            bump="patch"
          else
            # Optional heuristic fallback when commit messages don't follow Conventional Commits.
            # If a single commit is "big", bump minor.
            total_changes="$(git show --numstat --format='' HEAD | awk '
              $1 ~ /^[0-9]+$/ && $2 ~ /^[0-9]+$/ { add += $1; del += $2 }
              END { print add + del }
            ')"
            total_changes="${total_changes:-0}"
            echo "Heuristic change size (add+del): $total_changes"
            if [ "$total_changes" -ge 500 ]; then
              bump="minor"
            fi
          fi

          echo "Bump: $bump"

          latest_tag="$(git tag -l 'v*' --sort=-v:refname | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | head -n1 || true)"
          if [ -z "$latest_tag" ]; then
            cargo_ver="$(awk '
              /^\[workspace\.package\]/ { in_section=1; next }
              /^\[/ { in_section=0 }
              in_section && /^version[[:space:]]*=/ {
                gsub(/"/, "", $3);
                print $3;
                exit
              }
            ' Cargo.toml)"
            if [ -z "$cargo_ver" ]; then
              echo "::error::Could not find a previous vX.Y.Z tag and could not read [workspace.package].version from Cargo.toml"
              exit 1
            fi
            latest_tag="v$cargo_ver"
          fi

          base="${latest_tag#v}"
          IFS='.' read -r major minor patch <<< "$base"

          case "$bump" in
            major)
              major=$((major + 1))
              minor=0
              patch=0
              ;;
            minor)
              minor=$((minor + 1))
              patch=0
              ;;
            patch)
              patch=$((patch + 1))
              ;;
          esac

          next="v${major}.${minor}.${patch}"

          # Ensure uniqueness in case of races or manual tags.
          while git rev-parse -q --verify "refs/tags/$next" >/dev/null; do
            patch=$((patch + 1))
            next="v${major}.${minor}.${patch}"
          done

          echo "next_tag=$next" >> "$GITHUB_OUTPUT"
          echo "Next tag: $next"

  build:
    name: Build and package (${{ matrix.os_name }})
    needs: version
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            os_name: windows
          - os: ubuntu-22.04
            target: x86_64-unknown-linux-gnu
            os_name: linux
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: stable
          targets: ${{ matrix.target }}

      - name: Download and prepare Wintun DLL (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          $wintunVersion = "${{ env.WINTUN_VERSION }}"
          $wintunUrl = "https://www.wintun.net/builds/wintun-$wintunVersion.zip"
          $wintunZip = "wintun.zip"
          $expectedHash = "${{ env.WINTUN_SHA256 }}"

          Write-Host "Downloading Wintun $wintunVersion..."
          Invoke-WebRequest -Uri $wintunUrl -OutFile $wintunZip

          Write-Host "Verifying checksum..."
          $actualHash = (Get-FileHash -Path $wintunZip -Algorithm SHA256).Hash.ToLower()
          if ($actualHash -ne $expectedHash) {
            Write-Error "Checksum verification failed! Expected: $expectedHash, Got: $actualHash"
            exit 1
          }
          Write-Host "âœ“ Checksum verified successfully"

          Write-Host "Extracting Wintun..."
          Expand-Archive -Path $wintunZip -DestinationPath wintun-temp

          New-Item -ItemType Directory -Force -Path resources | Out-Null
          Copy-Item "wintun-temp/wintun/bin/amd64/wintun.dll" "resources/wintun_amd64.dll"
          Copy-Item "wintun-temp/wintun/bin/x86/wintun.dll" "resources/wintun_x86.dll"
          Copy-Item "wintun-temp/wintun/bin/arm64/wintun.dll" "resources/wintun_arm64.dll"
          Copy-Item "wintun-temp/wintun/bin/arm/wintun.dll" "resources/wintun_arm.dll"

          Remove-Item -Recurse -Force wintun-temp
          Remove-Item $wintunZip

      - name: Build
        run: cargo build --release --target ${{ matrix.target }} -p bonding-client -p bonding-server --verbose

      - name: Package (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          $target = "${{ matrix.target }}"

          $packages = @(
            @{ Name = "bonding-client"; Binary = "bonding-client.exe"; Archive = "bonding-client-windows-$target.zip" },
            @{ Name = "bonding-server"; Binary = "bonding-server.exe"; Archive = "bonding-server-windows-$target.zip" }
          )

          foreach ($p in $packages) {
            if (Test-Path "package") { Remove-Item -Recurse -Force "package" }
            New-Item -ItemType Directory -Force -Path package | Out-Null

            $binPath = "target/$target/release/$($p.Binary)"
            if (-not (Test-Path $binPath)) {
              Write-Error "Expected binary not found: $binPath"
              exit 1
            }
            Copy-Item $binPath package/

            if (Test-Path "README.md") { Copy-Item "README.md" package/ }
            if (Test-Path "LICENSE-MIT") { Copy-Item "LICENSE-MIT" package/ }
            if (Test-Path "LICENSE-APACHE") { Copy-Item "LICENSE-APACHE" package/ }

            if (Test-Path $p.Archive) { Remove-Item -Force $p.Archive }
            Compress-Archive -Path package/* -DestinationPath $p.Archive
            Write-Host "Created archive: $($p.Archive)"
          }

      - name: Package (Linux)
        if: matrix.os == 'ubuntu-22.04'
        run: |
          target="${{ matrix.target }}"

          for bin in bonding-client bonding-server; do
            archive_name="${bin}-linux-${target}.tar.gz"

            rm -rf package
            mkdir -p package

            if [ ! -f "target/${target}/release/${bin}" ]; then
              echo "Expected binary not found: target/${target}/release/${bin}" >&2
              exit 1
            fi
            cp "target/${target}/release/${bin}" package/

            [ -f README.md ] && cp README.md package/
            [ -f LICENSE-MIT ] && cp LICENSE-MIT package/
            [ -f LICENSE-APACHE ] && cp LICENSE-APACHE package/

            tar -czf "${archive_name}" -C package .
            echo "Created archive: ${archive_name}"
          done

      - name: Upload packaged artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-${{ matrix.os_name }}-${{ matrix.target }}
          path: |
            ./bonding-client-${{ matrix.os_name }}-${{ matrix.target }}.*
            ./bonding-server-${{ matrix.os_name }}-${{ matrix.target }}.*

  release:
    name: Publish GitHub Release
    needs: [version, build]
    runs-on: ubuntu-latest
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.version.outputs.next_tag }}
          name: Release ${{ needs.version.outputs.next_tag }}
          target_commitish: ${{ github.sha }}
          files: artifacts/**/*
          draft: false
          prerelease: false
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
